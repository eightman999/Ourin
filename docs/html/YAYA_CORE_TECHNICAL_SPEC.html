<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAYA Core 技術仕様書</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "游ゴシック", YuGothic, "メイリオ", Meiryo, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .content {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            border-bottom: 3px solid #333;
            padding-bottom: 10px;
            color: #333;
        }
        h2 {
            border-bottom: 2px solid #666;
            padding-bottom: 8px;
            margin-top: 30px;
            color: #444;
        }
        h3 {
            margin-top: 25px;
            color: #555;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "SF Mono", "Menlo", "Monaco", "Courier New", monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #333;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f8f8;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            border-left: 4px solid #ddd;
            padding-left: 20px;
            margin-left: 0;
            color: #666;
            font-style: italic;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 30px 0;
        }
        .toc {
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1 id="yaya-core">YAYA Core 技術仕様書</h1>
<p><strong>バージョン</strong>: 1.0<br />
<strong>日付</strong>: 2025-10-16<br />
<strong>対象</strong>: macOS (Universal Binary: arm64 + x86_64)<br />
<strong>ライセンス</strong>: BSD-3-Clause (YAYA準拠)</p>
<hr />
<h2 id="1">1. 概要</h2>
<h3 id="11">1.1 目的</h3>
<p>本ドキュメントは、Ourin向けYAYA Core実装の技術的な詳細を定義します。Windows版YAYAの言語仕様を参考にしつつ、macOSネイティブ環境に最適化された実装を提供します。</p>
<h3 id="12">1.2 スコープ</h3>
<ul>
<li>YAYA言語の字句解析・構文解析</li>
<li>YAYA仮想マシン（VM）の実装</li>
<li>SHIORI/3.0Mプロトコルとの統合</li>
<li>UTF-8/CP932文字コードのサポート</li>
</ul>
<h3 id="13">1.3 非スコープ</h3>
<ul>
<li>Windows DLLバイナリ互換（不可能）</li>
<li>SAORI連携（Phase 2以降）</li>
<li>デバッガUI（将来拡張）</li>
</ul>
<hr />
<h2 id="2-yaya">2. YAYA言語仕様（実装対象）</h2>
<h3 id="21-lexical-elements">2.1 字句要素（Lexical Elements）</h3>
<h4 id="211">2.1.1 トークン種別</h4>
<pre><code class="language-cpp">enum class TokenType {
    // リテラル
    String,          // &quot;文字列&quot;
    Integer,         // 123
    Float,           // 3.14

    // 識別子・キーワード
    Identifier,      // 変数名・関数名
    If,              // if
    Else,            // else
    ElseIf,          // elseif
    When,            // when
    While,           // while
    For,             // for
    Foreach,         // foreach
    Break,           // break
    Continue,        // continue
    Return,          // return

    // 演算子
    Assign,          // =
    Plus,            // +
    Minus,           // -
    Multiply,        // *
    Divide,          // /
    Modulo,          // %
    Equal,           // ==
    NotEqual,        // !=
    Less,            // &lt;
    Greater,         // &gt;
    LessEqual,       // &lt;=
    GreaterEqual,    // &gt;=
    LogicalAnd,      // &amp;&amp;
    LogicalOr,       // ||
    LogicalNot,      // !
    BitwiseAnd,      // &amp;
    BitwiseOr,       // |
    BitwiseXor,      // ^
    LeftShift,       // &lt;&lt;
    RightShift,      // &gt;&gt;
    Increment,       // ++
    Decrement,       // --
    Question,        // ?
    Colon,           // :
    Comma,           // ,
    Semicolon,       // ;
    Match,           // =~ (正規表現マッチ)
    NotMatch,        // !~ (正規表現非マッチ)

    // 区切り文字
    LeftBrace,       // {
    RightBrace,      // }
    LeftParen,       // (
    RightParen,      // )
    LeftBracket,     // [
    RightBracket,    // ]

    // 特殊
    Comment,         // // または /* */
    Newline,         // 改行
    Eof,             // ファイル終端
    Invalid          // エラートークン
};
</code></pre>
<h4 id="212">2.1.2 コメント</h4>
<pre><code class="language-yaya">// 行コメント（行末まで）

/*
 * ブロックコメント
 * 複数行対応
 */
</code></pre>
<h4 id="213">2.1.3 文字列リテラル</h4>
<pre><code class="language-yaya">// 基本文字列
&quot;Hello, World&quot;

// SakuraScript埋め込み
&quot;\0\s[0]こんにちは\e&quot;

// エスケープシーケンス
&quot;改行\n タブ\t クォート\&quot; バックスラッシュ\\&quot;
</code></pre>
<p><strong>エスケープ処理</strong>:
- <code>\n</code> → LF (0x0A)
- <code>\t</code> → TAB (0x09)
- <code>\"</code> → <code>"</code>
- <code>\\</code> → <code>\</code>
- その他 → そのまま（SakuraScript互換）</p>
<h3 id="22">2.2 データ型</h3>
<h4 id="221">2.2.1 基本型</h4>
<pre><code class="language-cpp">class Value {
public:
    enum class Type {
        Void,       // 未初期化・戻り値なし
        Integer,    // 整数（int64_t）
        Float,      // 浮動小数点（double）
        String,     // 文字列（std::string, UTF-8）
        Array,      // 配列（std::vector&lt;Value&gt;）
        Dict        // 連想配列（std::map&lt;std::string, Value&gt;）
    };

private:
    Type type_;
    std::variant&lt;
        std::monostate,              // Void
        int64_t,                     // Integer
        double,                      // Float
        std::string,                 // String
        std::vector&lt;Value&gt;,          // Array
        std::map&lt;std::string, Value&gt; // Dict
    &gt; data_;
};
</code></pre>
<h4 id="222">2.2.2 型変換規則</h4>
<p><strong>暗黙的変換</strong>:</p>
<pre><code class="language-yaya">// 数値 → 文字列（算術演算外の文脈）
_var = 123 + &quot;abc&quot;  // &quot;123abc&quot;

// 文字列 → 数値（算術演算）
_num = &quot;123&quot; + 456  // 579

// 論理値（真偽判定）
// - 整数: 0 = false, 非0 = true
// - 文字列: &quot;&quot; = false, 非空 = true
// - 配列: 空 = false, 非空 = true
</code></pre>
<h3 id="23">2.3 式と文</h3>
<h4 id="231-expressions">2.3.1 式（Expressions）</h4>
<pre><code class="language-yaya">// 算術式
_result = (10 + 20) * 3 / 2

// 比較式
_is_greater = _a &gt; _b

// 論理式
_both = (_a &gt; 0) &amp;&amp; (_b &lt; 100)

// 三項演算子
_value = _condition ? &quot;yes&quot; : &quot;no&quot;

// 文字列連結
_greeting = &quot;Hello, &quot; + _name

// 配列アクセス
_item = _array[0]

// 関数呼び出し
_random = RAND(10)
</code></pre>
<h4 id="232-statements">2.3.2 文（Statements）</h4>
<pre><code class="language-yaya">// 代入文
_var = 123

// 条件分岐
if _condition {
    // 真の場合
}
elseif _another {
    // 別の条件
}
else {
    // それ以外
}

// when文（値による分岐）
when _value {
    1: { &quot;one&quot; }
    2: { &quot;two&quot; }
    others: { &quot;many&quot; }
}

// while文
while _count &lt; 10 {
    _count++
}

// foreach文
foreach _array; _item {
    // _itemで各要素にアクセス
}

// break/continue
break
continue

// return（関数終了・戻り値）
return _result
</code></pre>
<h3 id="24">2.4 関数定義</h3>
<h4 id="241">2.4.1 基本構文</h4>
<pre><code class="language-yaya">// 関数定義
FunctionName {
    // 処理
    return &quot;result&quot;
}

// 引数なし関数
OnBoot {
    &quot;\0\s[0]起動しました\e&quot;
}

// 引数あり関数（暗黙的パラメータ）
OnMouseClick {
    // reference[0], reference[1], ... で引数アクセス
    when reference[0] {
        0: { &quot;\0\s[0]さくらがクリックされました&quot; }
        1: { &quot;\1\s[10]うにゅうがクリックされました&quot; }
    }
}
</code></pre>
<h4 id="242">2.4.2 組み込み変数</h4>
<p><strong>SHIORI固有</strong>:</p>
<pre><code class="language-yaya">reference[0]     // 第1引数
reference[1]     // 第2引数
reference[n]     // 第n+1引数

charset          // 文字コード（&quot;UTF-8&quot; など）
sender           // 送信元（&quot;Ourin&quot; など）
</code></pre>
<p><strong>システム変数</strong>:</p>
<pre><code class="language-yaya">// 実装予定
_argc            // 引数の数
_argv[n]         // 引数配列（reference[]のエイリアス）
</code></pre>
<h3 id="25">2.5 組み込み関数</h3>
<h4 id="251-phase-1">2.5.1 Phase 1 必須関数</h4>
<p><strong>乱数</strong>:</p>
<pre><code class="language-yaya">RAND(max)        // 0 〜 max-1 の整数乱数
</code></pre>
<p><strong>文字列操作</strong>:</p>
<pre><code class="language-yaya">STRLEN(str)      // 文字列長（UTF-8文字数）
STRSTR(hay, needle, [start])  // 部分文字列検索（位置返却、-1=未発見、start省略可）
SUBSTR(str, start, len)  // 部分文字列取得
TOUPPER(str)     // 大文字化
TOLOWER(str)     // 小文字化
</code></pre>
<p><strong>配列操作</strong>:</p>
<pre><code class="language-yaya">ARRAYSIZE(arr)   // 配列サイズ
IARRAY           // 空配列作成
</code></pre>
<p><strong>型変換</strong>:</p>
<pre><code class="language-yaya">TOINT(val)       // 整数化
TOSTR(val)       // 文字列化
</code></pre>
<p><strong>判定</strong>:</p>
<pre><code class="language-yaya">ISVAR(varname)   // 変数が定義済みか
ISFUNC(funcname) // 関数が定義済みか
</code></pre>
<h4 id="252-phase-2">2.5.2 Phase 2 拡張関数</h4>
<p><strong>正規表現</strong>:</p>
<pre><code class="language-yaya">RE_MATCH(str, pattern)     // マッチ判定
RE_SEARCH(str, pattern)    // マッチ位置
RE_REPLACE(str, pattern, replacement)  // 置換
</code></pre>
<p><strong>日時</strong>:</p>
<pre><code class="language-yaya">GETTIME[0]       // 年
GETTIME[1]       // 月
GETTIME[2]       // 日
GETTIME[3]       // 時
GETTIME[4]       // 分
GETTIME[5]       // 秒
</code></pre>
<p><strong>ファイル操作</strong>:</p>
<pre><code class="language-yaya">FOPEN(path, mode)
FREAD(handle)
FWRITE(handle, data)
FCLOSE(handle)
</code></pre>
<hr />
<h2 id="3">3. アーキテクチャ詳細</h2>
<h3 id="31">3.1 クラス構成</h3>
<pre><code>yaya_core/src/
├── main.cpp                    # エントリポイント
├── YayaCore.{cpp,hpp}          # コントローラー
├── DictionaryManager.{cpp,hpp} # 辞書管理
├── Lexer.{cpp,hpp}             # 字句解析
├── Parser.{cpp,hpp}            # 構文解析
├── AST.{cpp,hpp}               # 抽象構文木
├── VM.{cpp,hpp}                # 仮想マシン
├── Value.{cpp,hpp}             # 値型
├── FunctionRegistry.{cpp,hpp}  # 関数テーブル
├── VariableStore.{cpp,hpp}     # 変数ストレージ
├── BuiltinFunctions.{cpp,hpp}  # 組み込み関数
├── ShioriAdapter.{cpp,hpp}     # SHIORI変換
└── Utils.{cpp,hpp}             # ユーティリティ
</code></pre>
<h3 id="32-lexer">3.2 字句解析器（Lexer）</h3>
<h4 id="321">3.2.1 責務</h4>
<ul>
<li>ファイル読み込み（UTF-8/CP932自動検出）</li>
<li>トークン列への分割</li>
<li>コメント除去</li>
<li>エラー位置記録</li>
</ul>
<h4 id="322">3.2.2 インターフェース</h4>
<pre><code class="language-cpp">class Lexer {
public:
    explicit Lexer(std::string source);

    std::vector&lt;Token&gt; tokenize();

private:
    std::string source_;
    size_t pos_;
    size_t line_;
    size_t column_;

    char peek();
    char advance();
    bool match(char expected);

    Token makeToken(TokenType type);
    Token makeString();
    Token makeNumber();
    Token makeIdentifier();

    void skipWhitespace();
    void skipLineComment();
    void skipBlockComment();
};
</code></pre>
<h3 id="33-parser">3.3 構文解析器（Parser）</h3>
<h4 id="331-bnf">3.3.1 文法（簡略版BNF）</h4>
<pre><code>Program       := FunctionDef*
FunctionDef   := Identifier '{' Statement* '}'
Statement     := IfStmt | WhileStmt | ForEachStmt | ReturnStmt | ExprStmt
IfStmt        := 'if' Expression '{' Statement* '}' ElseClause?
ElseClause    := 'else' (IfStmt | '{' Statement* '}')
WhileStmt     := 'while' Expression '{' Statement* '}'
ForEachStmt   := 'foreach' Expression ';' Identifier '{' Statement* '}'
ReturnStmt    := 'return' Expression?
ExprStmt      := Expression

Expression    := Assignment
Assignment    := Ternary ('=' Assignment)?
Ternary       := LogicalOr ('?' Expression ':' Ternary)?
LogicalOr     := LogicalAnd ('||' LogicalAnd)*
LogicalAnd    := Equality ('&amp;&amp;' Equality)*
Equality      := Relational (('==' | '!=') Relational)*
Relational    := Additive (('&lt;' | '&gt;' | '&lt;=' | '&gt;=') Additive)*
Additive      := Multiplicative (('+' | '-') Multiplicative)*
Multiplicative := Unary (('*' | '/' | '%') Unary)*
Unary         := ('!' | '-' | '++' | '--') Unary | Postfix
Postfix       := Primary ('++' | '--' | '[' Expression ']' | '(' ArgList? ')')*
Primary       := Identifier | Number | String | '(' Expression ')'

ArgList       := Expression (',' Expression)*
</code></pre>
<h4 id="332-ast">3.3.2 抽象構文木（AST）</h4>
<pre><code class="language-cpp">// 基底クラス
class ASTNode {
public:
    virtual ~ASTNode() = default;
    virtual Value evaluate(VM&amp; vm) = 0;
};

// 式ノード
class ExpressionNode : public ASTNode { /* ... */ };
class BinaryOpNode : public ExpressionNode { /* ... */ };
class UnaryOpNode : public ExpressionNode { /* ... */ };
class LiteralNode : public ExpressionNode { /* ... */ };
class IdentifierNode : public ExpressionNode { /* ... */ };
class CallNode : public ExpressionNode { /* ... */ };

// 文ノード
class StatementNode : public ASTNode { /* ... */ };
class IfStatementNode : public StatementNode { /* ... */ };
class WhileStatementNode : public StatementNode { /* ... */ };
class ReturnStatementNode : public StatementNode { /* ... */ };

// 関数定義
class FunctionNode : public ASTNode {
public:
    std::string name;
    std::vector&lt;std::shared_ptr&lt;StatementNode&gt;&gt; body;
};
</code></pre>
<h3 id="34-vm">3.4 仮想マシン（VM）</h3>
<h4 id="341">3.4.1 実行モデル</h4>
<pre><code class="language-cpp">class VM {
public:
    Value execute(const FunctionNode&amp; func, const std::vector&lt;Value&gt;&amp; args);

    // 変数アクセス
    Value getVariable(const std::string&amp; name);
    void setVariable(const std::string&amp; name, const Value&amp; value);

    // 組み込み関数呼び出し
    Value callBuiltin(const std::string&amp; name, const std::vector&lt;Value&gt;&amp; args);

private:
    VariableStore variables_;
    FunctionRegistry functions_;
    BuiltinFunctions builtins_;

    // 実行スタック（関数呼び出し）
    struct CallFrame {
        std::string functionName;
        std::map&lt;std::string, Value&gt; localVars;
    };
    std::vector&lt;CallFrame&gt; callStack_;
};
</code></pre>
<h4 id="342">3.4.2 実行フロー</h4>
<ol>
<li><strong>関数呼び出し</strong></li>
<li>新しいCallFrameをスタックに積む</li>
<li>ローカル変数スコープ作成</li>
<li>
<p>引数を<code>reference[]</code>に設定</p>
</li>
<li>
<p><strong>文の実行</strong></p>
</li>
<li>ASTノードを再帰的に評価</li>
<li>
<p>変数代入・関数呼び出し処理</p>
</li>
<li>
<p><strong>戻り値処理</strong></p>
</li>
<li><code>return</code>文で明示的に返却</li>
<li>
<p>または関数末尾の式評価結果</p>
</li>
<li>
<p><strong>スタック解放</strong></p>
</li>
<li>CallFrameをpop</li>
<li>ローカル変数破棄</li>
</ol>
<h3 id="35">3.5 変数ストア</h3>
<pre><code class="language-cpp">class VariableStore {
public:
    Value get(const std::string&amp; name);
    void set(const std::string&amp; name, const Value&amp; value);
    bool exists(const std::string&amp; name);
    void clear();

private:
    std::unordered_map&lt;std::string, Value&gt; globals_;
    // スコープ管理（将来拡張）
};
</code></pre>
<p><strong>変数命名規則</strong>:
- <code>_var</code>: ローカル変数（関数内）
- <code>var</code>: グローバル変数
- <code>reference[n]</code>: SHIORI引数（読み取り専用）</p>
<h3 id="36-shiori">3.6 SHIORI アダプタ</h3>
<h4 id="361">3.6.1 リクエスト処理</h4>
<pre><code class="language-cpp">class ShioriAdapter {
public:
    std::string processRequest(const std::string&amp; method, 
                               const std::string&amp; id,
                               const std::map&lt;std::string, std::string&gt;&amp; headers,
                               const std::vector&lt;std::string&gt;&amp; references);

private:
    VM&amp; vm_;

    void setReferenceVariables(const std::vector&lt;std::string&gt;&amp; refs);
    std::string buildResponse(const Value&amp; result, int status);
};
</code></pre>
<h4 id="362">3.6.2 レスポンス形式</h4>
<p><strong>GET成功時</strong>:</p>
<pre><code>SHIORI/3.0 200 OK
Charset: UTF-8
Sender: yaya_core

\0\s[0]こんにちは\e
</code></pre>
<p><strong>NOTIFY成功時</strong>:</p>
<pre><code>SHIORI/3.0 204 No Content
Charset: UTF-8
</code></pre>
<p><strong>エラー時</strong>:</p>
<pre><code>SHIORI/3.0 500 Internal Server Error
Charset: UTF-8

Error: Function 'Unknown' not found
</code></pre>
<hr />
<h2 id="4">4. 文字コード処理</h2>
<h3 id="41">4.1 対応エンコーディング</h3>
<ul>
<li><strong>UTF-8</strong>: 標準（推奨）</li>
<li><strong>CP932</strong> (Shift_JIS): Windows互換</li>
</ul>
<h3 id="42">4.2 自動検出アルゴリズム</h3>
<pre><code class="language-cpp">Encoding detectEncoding(const std::vector&lt;uint8_t&gt;&amp; data) {
    // 1. BOMチェック
    if (hasUtf8Bom(data)) return Encoding::UTF8;

    // 2. UTF-8妥当性検証
    if (isValidUtf8(data)) return Encoding::UTF8;

    // 3. CP932とみなす（フォールバック）
    return Encoding::CP932;
}
</code></pre>
<h3 id="43">4.3 変換処理</h3>
<pre><code class="language-cpp">std::string convertToUtf8(const std::vector&lt;uint8_t&gt;&amp; data, Encoding enc) {
    if (enc == Encoding::UTF8) {
        return std::string(data.begin(), data.end());
    }

    // ICU使用
    UErrorCode status = U_ZERO_ERROR;
    UConverter* conv = ucnv_open(&quot;windows-932&quot;, &amp;status);
    // ... 変換処理
    ucnv_close(conv);

    return utf8_result;
}
</code></pre>
<hr />
<h2 id="5">5. エラーハンドリング</h2>
<h3 id="51">5.1 エラー種別</h3>
<pre><code class="language-cpp">enum class ErrorType {
    LexicalError,    // 字句解析エラー
    SyntaxError,     // 構文エラー
    RuntimeError,    // 実行時エラー
    TypeError,       // 型エラー
    NameError,       // 未定義名
    FileError        // ファイルI/Oエラー
};

class YayaException : public std::exception {
public:
    YayaException(ErrorType type, const std::string&amp; message, 
                  size_t line, size_t column);

    ErrorType type() const;
    std::string message() const;
    size_t line() const;
    size_t column() const;
};
</code></pre>
<h3 id="52">5.2 エラー報告</h3>
<p><strong>開発時（詳細）</strong>:</p>
<pre><code>Error: Undefined variable '_unknown'
  at line 42, column 15 in aya_bootend.dic

  41: if _condition {
  42:     _result = _unknown + 123
                    ^^^^^^^^^
  43: }
</code></pre>
<p><strong>本番時（簡潔）</strong>:</p>
<pre><code class="language-json">{
  &quot;ok&quot;: false,
  &quot;status&quot;: 500,
  &quot;error&quot;: &quot;RuntimeError: Undefined variable '_unknown' (aya_bootend.dic:42)&quot;
}
</code></pre>
<hr />
<h2 id="6">6. パフォーマンス最適化</h2>
<h3 id="61">6.1 目標</h3>
<ul>
<li><strong>辞書ロード</strong>: &lt; 500ms (Emily4全体)</li>
<li><strong>関数実行</strong>: &lt; 10ms (OnBoot)</li>
<li><strong>メモリ使用</strong>: &lt; 100MB (辞書ロード後)</li>
</ul>
<h3 id="62">6.2 最適化手法</h3>
<h4 id="621-phase-1">6.2.1 Phase 1（基本）</h4>
<ul>
<li>ASTキャッシュ（再パース不要）</li>
<li>文字列インターン（重複文字列の共有）</li>
<li>関数テーブルのハッシュマップ化</li>
</ul>
<h4 id="622-phase-2">6.2.2 Phase 2（拡張）</h4>
<ul>
<li>バイトコードコンパイル</li>
<li>JIT コンパイル（LLVM使用、将来）</li>
<li>メモリプール</li>
</ul>
<h3 id="63">6.3 プロファイリング</h3>
<pre><code class="language-bash"># Instruments（macOS標準）
instruments -t &quot;Time Profiler&quot; ./yaya_core

# Valgrind（メモリリーク検出）
valgrind --leak-check=full ./yaya_core &lt; test_input.json
</code></pre>
<hr />
<h2 id="7">7. テスト仕様</h2>
<h3 id="71">7.1 ユニットテスト構成</h3>
<pre><code>yaya_core/tests/
├── lexer_test.cpp
├── parser_test.cpp
├── vm_test.cpp
├── builtin_test.cpp
└── integration_test.cpp
</code></pre>
<h3 id="72">7.2 テストケース例</h3>
<pre><code class="language-cpp">// Lexerテスト
TEST(LexerTest, TokenizeString) {
    Lexer lex(R&quot;(&quot;Hello, World&quot;)&quot;);
    auto tokens = lex.tokenize();
    ASSERT_EQ(tokens.size(), 2); // String + EOF
    EXPECT_EQ(tokens[0].type, TokenType::String);
    EXPECT_EQ(tokens[0].value, &quot;Hello, World&quot;);
}

// Parserテスト
TEST(ParserTest, ParseFunctionDefinition) {
    Parser parser(&quot;OnBoot { \&quot;test\&quot; }&quot;);
    auto ast = parser.parse();
    ASSERT_EQ(ast.functions.size(), 1);
    EXPECT_EQ(ast.functions[0].name, &quot;OnBoot&quot;);
}

// VMテスト
TEST(VMTest, ExecuteSimpleFunction) {
    VM vm;
    // ... 関数登録
    auto result = vm.execute(&quot;OnBoot&quot;, {});
    EXPECT_EQ(result.asString(), &quot;\\0\\s[0]test\\e&quot;);
}
</code></pre>
<h3 id="73">7.3 統合テスト</h3>
<pre><code class="language-cpp">TEST(IntegrationTest, LoadEmily4) {
    DictionaryManager dm;
    bool ok = dm.load({
        &quot;emily4/ghost/master/aya_bootend.dic&quot;,
        // ... 他の辞書
    }, &quot;utf-8&quot;);
    ASSERT_TRUE(ok);

    auto response = dm.execute(&quot;OnBoot&quot;, {});
    EXPECT_FALSE(response.empty());
    EXPECT_TRUE(response.find(&quot;\\0\\s[&quot;) != std::string::npos);
}
</code></pre>
<hr />
<h2 id="8">8. ライセンスとクレジット</h2>
<h3 id="81-yaya-core">8.1 YAYA Core ライセンス</h3>
<p><strong>BSD-3-Clause License</strong>（公式YAYA準拠）</p>
<pre><code>Copyright (c) 2025, Ourin Project
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
...
</code></pre>
<h3 id="82">8.2 依存ライブラリ</h3>
<ul>
<li><strong>nlohmann/json</strong>: MIT License</li>
<li><strong>ICU</strong>: Unicode License</li>
<li><strong>Google Test</strong>: BSD-3-Clause License</li>
</ul>
<h3 id="83">8.3 参考実装クレジット</h3>
<p>本実装は以下を参考にしています:
- <strong>YAYA (C++)</strong>: https://github.com/YAYA-shiori/yaya-shiori (BSD-3-Clause)
- <strong>yaya-rs (Rust)</strong>: https://github.com/apxxxxxxe/yaya-rs (MIT)</p>
<hr />
<h2 id="9">9. バージョン履歴</h2>
<ul>
<li><strong>1.0</strong> (2025-10-16): 初版作成</li>
</ul>
<hr />
<p><strong>ドキュメント管理</strong><br />
- リポジトリ: https://github.com/eightman999/Ourin
- パス: <code>docs/YAYA_CORE_TECHNICAL_SPEC.md</code></p>
        <div class="footer">
            <p>Ourin (桜鈴) - macOS ネイティブ伺かベースウェア</p>
        </div>
    </div>
</body>
</html>