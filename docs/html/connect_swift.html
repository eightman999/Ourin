<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yaya_core から Swift 製プラグインを扱う手順</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "游ゴシック", YuGothic, "メイリオ", Meiryo, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .content {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            border-bottom: 3px solid #333;
            padding-bottom: 10px;
            color: #333;
        }
        h2 {
            border-bottom: 2px solid #666;
            padding-bottom: 8px;
            margin-top: 30px;
            color: #444;
        }
        h3 {
            margin-top: 25px;
            color: #555;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "SF Mono", "Menlo", "Monaco", "Courier New", monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #333;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f8f8;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            border-left: 4px solid #ddd;
            padding-left: 20px;
            margin-left: 0;
            color: #666;
            font-style: italic;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 30px 0;
        }
        .toc {
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1 id="yaya_core-swift">yaya_core から Swift 製プラグインを扱う手順</h1>
<p>本書では、<code>yaya_core</code>（C++ 製ヘルパー実行ファイル）から macOS ネイティブの Swift プラグイン（<code>.plugin</code> / <code>.bundle</code>）をロードし、SHIORI/PLUGIN プロトコルのやり取りを行うための手順を整理します。すべて UTF-8 を既定とし、記述は日本語で統一しています。</p>
<h2 id="1">1. 全体像</h2>
<ol>
<li>Swift で PLUGIN/2.0M 仕様に準拠したロード可能バンドルを用意する。</li>
<li>バンドルをアプリの <code>Ourin.app/Contents/PlugIns/</code> など既定ディレクトリへ配置する。</li>
<li><code>yaya_core</code> が CFBundle API を介してプラグインをロードし、<code>load</code> / <code>request</code> / <code>unload</code> を呼び出す。</li>
<li>PLUGIN で返されたワイヤ文字列を <code>yaya_core</code> 側でパースし、JSON IPC 応答として Swift 層へ返す。</li>
</ol>
<p>Swift プラグインは Swift コードで実装されますが、エクスポートは C ABI で提供されるため、<code>yaya_core</code>（C++）からも透過的に呼び出すことができます。</p>
<h2 id="2-swift">2. Swift プラグインの要件</h2>
<h3 id="21">2.1 ターゲット設定</h3>
<ul>
<li>Xcode で <strong>Bundle（Mach-O Type: Bundle）</strong> を選択し、出力拡張子を <code>.plugin</code> に設定します。</li>
<li><strong>Architectures:</strong> <code>arm64</code> / <code>x86_64</code>（Universal 2）を有効にすること。</li>
<li><strong>Deployment Target:</strong> macOS 10.15 以上。</li>
</ul>
<h3 id="22">2.2 エクスポート関数</h3>
<p>Swift コードからは <code>@_cdecl</code> で C ABI の関数を公開します。</p>
<pre><code class="language-swift">@_cdecl(&quot;load&quot;)
public func pluginLoad(_ pluginDir: UnsafePointer&lt;CChar&gt;) -&gt; Int32 {
    // 初期化処理（必要ならバンドルパス解析など）
    return 0
}

@_cdecl(&quot;request&quot;)
public func pluginRequest(_ bytes: UnsafePointer&lt;UInt8&gt;, _ length: Int, _ outLength: UnsafeMutablePointer&lt;Int&gt;) -&gt; UnsafePointer&lt;UInt8&gt;? {
    let data = Data(bytes: bytes, count: length)
    guard let response = handleWire(String(decoding: data, as: UTF8.self)) else {
        outLength.pointee = 0
        return nil
    }
    let utf8 = Array(response.utf8)
    let buffer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: utf8.count)
    _ = buffer.initialize(from: utf8, count: utf8.count)
    outLength.pointee = utf8.count
    return UnsafePointer(buffer)
}

@_cdecl(&quot;unload&quot;)
public func pluginUnload() {
    // 後始末
}
@_cdecl(&quot;plugin_free&quot;)
public func pluginFree(_ pointer: UnsafeMutablePointer&lt;UInt8&gt;?) {
    pointer?.deallocate()
}
</code></pre>
<blockquote>
<p><strong>メモ:</strong> <code>request</code> から返すバッファはライフサイクル管理が重要です。コピーして返す場合は、<code>plugin_free</code> を併せて公開し <code>yaya_core</code> 側が解放できるようにします。</p>
</blockquote>
<h2 id="3">3. プラグインの配置</h2>
<ul>
<li><code>Ourin.app</code> バンドル配下の <code>Contents/PlugIns/</code> に配置するのが推奨です。</li>
<li>プラグインバンドル内には最低限 <code>Contents/Info.plist</code> と <code>Contents/MacOS/&lt;Executable&gt;</code>、<code>Contents/Resources/descript.txt</code> を含めます。</li>
<li><code>descript.txt</code> の <code>filename</code> は <code>.plugin</code> を指定し、文字コードは UTF-8 を推奨します。</li>
</ul>
<h2 id="4-yaya_core">4. yaya_core 側でのロード処理</h2>
<p>C++17 以降で CoreFoundation をリンクし、<code>CFBundle</code> API を利用します。以下は概念的なコード断片です。</p>
<pre><code class="language-cpp">#include &lt;CoreFoundation/CoreFoundation.h&gt;

struct PluginHandle {
    CFBundleRef bundle;
    using LoadFn = int32_t(*)(const char*);
    using RequestFn = const unsigned char*(*)(const unsigned char*, size_t, size_t*);
    using UnloadFn = void(*)();

    LoadFn load = nullptr;
    RequestFn request = nullptr;
    UnloadFn unload = nullptr;
};

PluginHandle loadPlugin(const std::string&amp; path) {
    PluginHandle handle{};
    CFURLRef url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFStringCreateWithCString(nullptr, path.c_str(), kCFStringEncodingUTF8), kCFURLPOSIXPathStyle, true);
    handle.bundle = CFBundleCreate(kCFAllocatorDefault, url);
    CFRelease(url);
    if (!handle.bundle || !CFBundleLoadExecutable(handle.bundle)) {
        throw std::runtime_error(&quot;Failed to load plugin bundle&quot;);
    }
    handle.request = reinterpret_cast&lt;PluginHandle::RequestFn&gt;(CFBundleGetFunctionPointerForName(handle.bundle, CFSTR(&quot;request&quot;)));
    handle.load = reinterpret_cast&lt;PluginHandle::LoadFn&gt;(CFBundleGetFunctionPointerForName(handle.bundle, CFSTR(&quot;load&quot;)));
    handle.unload = reinterpret_cast&lt;PluginHandle::UnloadFn&gt;(CFBundleGetFunctionPointerForName(handle.bundle, CFSTR(&quot;unload&quot;)));
    if (!handle.request) {
        throw std::runtime_error(&quot;request symbol missing&quot;);
    }
    return handle;
}
</code></pre>
<h3 id="41">4.1 ライフサイクル</h3>
<ol>
<li><code>load()</code> が存在する場合はバンドルディレクトリ（UTF-8 パス）を渡して初期化します。</li>
<li><code>request()</code> でワイヤ文字列（CRLF + 空行終端）を UTF-8 バイト列として渡します。</li>
<li><code>unload()</code> が存在する場合は終了処理で必ず呼び出します。</li>
<li><code>CFBundleUnloadExecutable</code> と <code>CFRelease</code> でバンドルを解放します。</li>
</ol>
<h2 id="5-json">5. ワイヤ ↔ JSON 変換</h2>
<ul>
<li>プラグインとの通信は <strong>PLUGIN/2.0M</strong> のワイヤ文字列です。</li>
<li><code>yaya_core</code> はこれを受け取り、SHIORI レイヤで <code>status</code> や <code>Value</code> を抽出して JSON IPC 形式にマッピングします。</li>
<li>例: Swift プラグインが <code>PLUGIN/2.0M 200 OK</code> を返した場合、<code>yaya_core</code> は <code>{ "ok": true, "status": 200, ... }</code> へ変換します。</li>
</ul>
<h2 id="6">6. エラー処理とデバッグ</h2>
<ul>
<li>シンボル取得に失敗した場合は即座にアンロードし、JSON IPC でエラーを返す。</li>
<li><code>request()</code> の戻り値が <code>nullptr</code> の場合は <code>500</code> 相当のエラーとして扱う。</li>
<li>Xcode の <code>DYLD_PRINT_LIBRARIES</code> や <code>CFBundleCopyBundleURL</code> でロード状況を確認できます。</li>
<li>ログは JSON 形式で出力し、Swift 側・<code>yaya_core</code> 側で突き合わせます。</li>
</ul>
<h2 id="7">7. マルチアーキテクチャ対応</h2>
<ul>
<li>プラグインと <code>yaya_core</code> の両方を Universal 2 でビルドし、Rosetta 実行時の不整合を避けます。</li>
<li><code>lipo -info MyPlugin.plugin/Contents/MacOS/MyPlugin</code> でアーキテクチャを確認します。</li>
</ul>
<h2 id="8">8. テスト戦略</h2>
<ol>
<li><strong>単体テスト:</strong> Swift プラグイン側で <code>request()</code> の入出力を XCTest で検証。</li>
<li><strong>結合テスト:</strong> <code>yaya_core</code> から実際にロードして JSON IPC 経由で応答を確認するスクリプトを整備。</li>
<li><strong>ロングラン:</strong> プラグインを連続ロード/アンロードし、メモリリークが発生しないかを Instruments で監視します。</li>
</ol>
<hr />
<p>以上が <code>yaya_core</code> から Swift 製プラグインを安全に扱うための手順です。実装時には <code>SPEC_PLUGIN_2.0M.md</code> や <code>OURIN_YAYA_ADAPTER_SPEC_1.0M.md</code> の規定も併せて参照し、ワイヤ仕様や IPC の整合性を確認してください。</p>
        <div class="footer">
            <p>Ourin (桜鈴) - macOS ネイティブ伺かベースウェア</p>
        </div>
    </div>
</body>
</html>